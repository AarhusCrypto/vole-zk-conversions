{% if ty.ty.bits in [32, 64] %}
    {% for idx in [i32, u64, i64] %}
        {% if VectorType(idx, ty.count) not in VECTOR_TYPES %}{% continue %}{% endif %}
        /// # Safety
        /// `base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet
        /// the safety requirements of [std::ptr::read_unaligned]
        impl crate::SimdBaseGatherable<{{ty.ty}}, {{idx}}, {{VectorType(idx, ty.count)}}> for {{ty}} {
            {% call(scalar, avx2) fn(
                "gather",
                {"base": "*const " ~ ty.ty, "indices": VectorType(idx, ty.count)},
                returns=ty,
                unsafe=True,
            ) %}
            {% call scalar() %}
                {{ty}}::from([
                    {% for i in range(ty.count) %}
                    base.offset(indices.as_array()[{{i}}] as isize).read_unaligned(),
                    {% endfor %}
                ])
            {% endcall %}
            {% call(avx2i) avx2() %}
                Self({{avx2i(ty, "gather", VectorType(idx, ty.count))}}::<{{ty.ty.bits // 8}}>(base as *const {{ty.ty.signed}}, indices.0))
            {% endcall %}
            {% endcall %}
        }
    {% endfor %}
{% endif %}
